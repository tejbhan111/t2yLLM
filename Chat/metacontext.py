import os
import sys
import subprocess
from datetime import datetime
import re
import time
import logging
import requests
from collections import Counter

# parent DIR for config loader
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

import spacy

import wikipedia

# pokemon searches
import difflib
from difflib import SequenceMatcher
from rapidfuzz import process, fuzz

# correctly formatting json generated by the LLM
# saving a lot of headaches
# from json_repair import repair_json
#
# CONFIG
from config.yamlConfigLoader import Loader

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[  # logging.FileHandler("/tmp/LLMStreamer.log"),
        logging.StreamHandler()
    ],
)
logger = logging.getLogger("LLMStreamer")

CONFIG = Loader().loadChatConfig()

UDP_IP = CONFIG.network.RCV_CMD_IP
UDP_PORT = CONFIG.network.RCV_CMD_PORT
BUFFER_SIZE = CONFIG.network.BUFFER_SIZE
AUTHORIZED_IPS = CONFIG.network.AUTHORIZED_IPS


class MetaSearch:
    def __init__(self):
        try:
            self.nlp = spacy.load(CONFIG.llms.spacy_model)
            # spacy is kinda very fast but sadly limited in french compared to
            # its english counterpart
        except Exception:
            print("downloading model Spacy model")
            os.system(f"python -m spacy download {CONFIG.llms.spacy_model}")
            self.nlp = spacy.load(CONFIG.llms.spacy_model)

        self.pokejson = ""
        self.wiki_query = False
        self.pokemon_list = self.load_pokemon_list(CONFIG.pokemon.pokemon_list)
        self.pokemon_phonetics = self.load_pokemon_list(
            CONFIG.pokemon.pokemon_phonetics
        )
        self.pokemon_query = False
        self.pokemon_name = ""

        self.wiki_query = False
        self.weather_query = False
        self.date_query = False
        self.location_query = False
        self.time_query = False

    # POKEMON
    def load_pokemon_list(self, filename):
        """
         loads the full pokedex from the text file,
        it is in french but can be changed ofc.
        one pokemon name per line
        It is also possible to create a local json db
        """
        try:
            with open(filename, "r", encoding="utf-8") as file:
                pokemon_names = [line.strip() for line in file if line.strip()]

            return pokemon_names
        except FileNotFoundError:
            print(f"{filename} doesnt seems to exist\nplease create a pokemon file")
            return []
        except Exception as e:
            print(f"Error Loading {filename}: {e}")
            return []

    def search_pokemon_tyradex(self, pokemon_name):
        """
        Uses french API Tyradex, can be change, but no
        switch implemented for english atm
        """
        try:
            url = f"https://tyradex.vercel.app/api/v1/pokemon/{pokemon_name}"

            headers = {
                "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
            }
            response = requests.get(url, headers=headers, timeout=10)

            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"Pokémon non trouvé sur Tyradex (statut: {response.status_code})",
                }

            self.pokejson = response.json()
            print(f"Tyradex data : {self.pokejson}")

            if "data" not in self.pokejson or not self.pokejson["data"]:
                return {
                    "success": False,
                    "error": "Données non disponibles pour ce Pokémon.",
                }

            return {"success": True, "Tyradex": self.pokejson}
        except Exception as e:
            return {
                "success": False,
                "error": f"Erreur lors de la recherche Tyradex: {str(e)}",
            }

    def translate_pokeinfo(self):
        """
        translates JSON from Tyradex into
        text that the LLM can process as context
        """
        json_data = self.pokejson
        if not json_data:
            return "Aucune donnée disponible pour ce Pokémon."
        else:
            try:
                # Extraction des informations de base
                name_fr = json_data.get("name", {}).get("fr", "Inconnu")
                pokedex_id = json_data.get("pokedex_id", "Inconnu")
                category = json_data.get("category", "Inconnu")
                generation = json_data.get("generation", "Inconnu")

                # Construction
                description = f"{name_fr} est un Pokémon de type "

                # Types
                types = json_data.get("types", [])
                type_names = [type_info.get("name", "") for type_info in types]
                if len(type_names) == 1:
                    description += f"{type_names[0]}"
                elif len(type_names) == 2:
                    description += f"{type_names[0]} et {type_names[1]}"
                else:
                    description += ", ".join(type_names[:-1]) + f" et {type_names[-1]}"

                # Numéro du Pokédex
                description += f". Il porte le numéro {pokedex_id} du Pokédex"
                if generation:
                    description += f" et est apparu dans la génération {generation}"
                description += "."

                # Catégorie
                if category and category != "Inconnu":
                    description += f" Il est connu comme le {category}."

                # Caractéristiques physiques
                try:
                    height = json_data.get("height", "Inconnu")
                    weight = json_data.get("weight", "Inconnu")
                    description += f" Il mesure {height} et pèse {weight}."
                except AttributeError or NameError:
                    pass

                # Talents
                try:
                    talents = json_data.get("talents", []) or []
                    if talents:
                        talent_names = []
                        tc_talents = []

                        for talent in talents:
                            name = talent.get("name", "")
                            is_tc = talent.get("tc", False)

                            if is_tc:
                                tc_talents.append(name)
                            else:
                                talent_names.append(name)

                        if talent_names:
                            description += (
                                f" Ses talents sont : {', '.join(talent_names)}"
                            )

                            if tc_talents:
                                description += f" et il possède le talent caché : {', '.join(tc_talents)}"
                            description += "."
                        elif tc_talents:
                            description += f" Il possède uniquement le talent caché : {', '.join(tc_talents)}."
                except AttributeError or NameError:
                    pass

                # Statistiques
                try:
                    stats = json_data.get("stats", {}) or {}
                    if stats:
                        description += f" Ses statistiques de base sont : {stats.get('hp', 0)} PV, "
                        description += f"{stats.get('atk', 0)} en Attaque, {stats.get('def', 0)} en Défense, "
                        description += f"{stats.get('spe_atk', 0)} en Attaque Spéciale, {stats.get('spe_def', 0)} en Défense Spéciale "
                        description += f"et {stats.get('vit', 0)} en Vitesse."
                except AttributeError or NameError:
                    pass

                # Évolutions
                try:
                    evolution = json_data.get("evolution", {})
                except AttributeError:
                    pass

                # Pré-évolutions
                try:
                    pre_evolutions = evolution.get("pre", []) or []
                    if pre_evolutions:
                        pre_evo = pre_evolutions[
                            0
                        ]  # On prend la première pré-évolution
                        pre_name = pre_evo.get("name", "")
                        pre_condition = pre_evo.get("condition", "")

                        if pre_name and pre_condition:
                            description += f" {name_fr} est l'évolution de {pre_name} ({pre_condition})."
                except AttributeError or NameError:
                    pass

                # Autres évolutions
                try:
                    next_evolutions = evolution.get("next", []) or []
                    if next_evolutions:
                        next_evo = next_evolutions[
                            0
                        ]  # On prend la première évolution suivante
                        next_name = next_evo.get("name", "")
                        next_condition = next_evo.get("condition", "")

                        if next_name and next_condition:
                            description += (
                                f" Il évolue en {next_name} ({next_condition})."
                            )
                except AttributeError or NameError:
                    pass

                # Méga-évolution
                try:
                    mega = evolution.get("mega", None)
                    if mega:
                        description += " Il possède une méga-évolution."
                except AttributeError or NameError:
                    pass

                # Taux de capture
                try:
                    catch_rate = json_data.get("catch_rate", None)
                    if catch_rate is not None:
                        description += f" Son taux de capture est de {catch_rate}."
                except AttributeError or NameError:
                    pass

                # Répartition male / femelle
                try:
                    sexe = json_data.get("sexe", {}) or {}
                    male_rate = sexe.get("male", 0)
                    female_rate = sexe.get("female", 0)

                    if male_rate > 0 and female_rate > 0:
                        description += f" La répartition des sexes est de {male_rate}% de mâles et {female_rate}% de femelles."
                    elif male_rate == 0 and female_rate == 0:
                        description += " Ce Pokémon est asexué."
                    elif male_rate == 0:
                        description += " Ce Pokémon est exclusivement femelle."
                    elif female_rate == 0:
                        description += " Ce Pokémon est exclusivement mâle."
                except AttributeError or NameError:
                    pass

                # Groupes d'œufs
                try:
                    egg_groups = json_data.get("egg_groups", [])
                    if egg_groups:
                        if len(egg_groups) == 1:
                            description += (
                                f" Il appartient au groupe d'œuf {egg_groups[0]}."
                            )
                        else:
                            description += f" Il appartient aux groupes d'œufs {' et '.join(egg_groups)}."
                except AttributeError or NameError:
                    pass

                # Résistances
                try:
                    resistances = json_data.get("resistances", [])

                    weaknesses = []
                    strengths = []
                    immunities = []

                    for res in resistances:
                        type_name = res.get("name", "")
                        multiplier = res.get("multiplier", 1)

                        if multiplier > 1:
                            weaknesses.append(f"{type_name} (x{multiplier})")
                        elif multiplier < 1 and multiplier > 0:
                            strengths.append(f"{type_name} (x{multiplier})")
                        elif multiplier == 0:
                            immunities.append(type_name)

                    if weaknesses:
                        description += f" Il est faible contre les attaques de type {', '.join(weaknesses)}."

                    if strengths:
                        description += (
                            f" Il résiste aux attaques de type {', '.join(strengths)}."
                        )

                    if immunities:
                        description += f" Il est immunisé contre les attaques de type {', '.join(immunities)}."
                except AttributeError or NameError:
                    pass

                # Formes spéciales
                try:
                    formes = json_data.get("formes", None)
                    if formes:
                        description += " Ce Pokémon possède différentes formes."
                except AttributeError or NameError:
                    pass

            except AttributeError or KeyError or IndexError or ValueError or TypeError:
                description = "info non trouvée sur ce pokémon"
                self.wiki_query = True

        return description

    def get_ipa_fr(self, word):
        result = subprocess.run(
            [
                "sudo",
                "-u",
                CONFIG.general.unprivileged_user,
                "espeak-ng",
                "-v",
                CONFIG.general.lang,
                "--ipa",
                "-q",
                word,
            ],
            capture_output=True,
            text=True,
        )
        phonetic = re.sub(r"\([a-z]{2,3}\)", "", result.stdout)
        return phonetic.strip()

    def similarity(self, a, b):
        return round(difflib.SequenceMatcher(None, a, b).ratio() * 100, 2)

    def detect_pokephonetics(self, user_input):
        """
        it is not working really well because there isnt really
        something worknig in french (but plenty in english)
        lets say it is not that accurate
        """
        doc = self.nlp(user_input)
        words = [token.text for token in doc if token.pos_ in ["NOUN", "VERB", "ADJ"]]
        # more special tokens exist in english but french model is limited

        best_match_index = None
        best_score = 0
        for word in words:
            word_ipa = self.get_ipa_fr(word)

            word_scores = []
            for i, pokemon_ipa in enumerate(self.pokemon_phonetics):
                score = self.similarity(word_ipa, pokemon_ipa)
                word_scores.append((i, score))

            if word_scores:
                word_scores.sort(key=lambda x: x[1], reverse=True)
                index, score = word_scores[0]

                if score > best_score:
                    best_match_index = index
                    best_score = score

        if best_match_index is None:
            return (None, 0)

        return best_match_index, best_score

    def detect_pokemon_in_text(
        self, user_input, threshold=CONFIG.pokemon.pokemon_find_threshold
    ):
        # threshold should be high at the begining but degressive if
        # it finds keywords related to pokemon query kind

        if not self.pokemon_list:
            print("La liste de Pokémon est vide.")
            return False

        words = user_input.split()
        accent_map = str.maketrans("éèêë", "eeee")

        for word in words:
            word = word.translate(accent_map)
            word = word.capitalize()
            matches = process.extract(
                word,
                self.pokemon_list,
                scorer=fuzz.ratio,
                limit=5,
            )
            print(f"matches = : {matches}")
            _, best_score = self.detect_pokephonetics(word)
            if (
                matches
                and (matches[0][1] >= threshold)
                or (
                    (matches[0][1] >= (threshold - 10))
                    and (best_score >= threshold + 4)
                )
            ):
                self.pokemon_query = True
                self.pokemon_name = matches[0][0]
                # return None
                return True

        self.pokemon_query = False
        return False

    # WIKIPEDIA
    def wiki_search(self, search_terms, original_query):
        wikipedia.set_lang(CONFIG.general.lang)

        search_query = search_terms

        try:
            search_results = wikipedia.search(
                search_query, results=CONFIG.wikipedia.wiki_sentence_search_nb
            )

            if not search_results:
                return {
                    "success": False,
                    "error": "Aucun résultat trouvé sur Wikipedia",
                    "query": search_query,
                }

            candidates = []
            for title in search_results:
                try:
                    page = wikipedia.page(title, auto_suggest=False)
                    summary = wikipedia.summary(
                        title,
                        sentences=CONFIG.wikipedia.summary_size,
                        auto_suggest=False,
                    )
                    relevance_score = self.get_wiki_score(
                        title, summary, original_query, search_terms
                    )
                    candidates.append(
                        {
                            "title": page.title,
                            "summary": summary,
                            "url": page.url,
                            "content": page.content[:1000],
                            "relevance": relevance_score,
                        }
                    )

                except (
                    wikipedia.exceptions.DisambiguationError,
                    wikipedia.exceptions.PageError,
                ) as e:
                    print(f"Error searching on Wikipedia {str(e)}")
                    continue
                except Exception as e:
                    print(f"Wiki Error trying with : {title}: {str(e)}")
                    continue

            candidates.sort(key=lambda x: x["relevance"], reverse=True)

            if not candidates:
                return {
                    "success": False,
                    "error": "Pas de contenu pertinent trouvé",
                    "query": search_query,
                }

            best_candidate = candidates[0]
            if best_candidate["relevance"] < 0.3:  # default 4
                return {
                    "success": False,
                    "error": "Résultats peu pertinents pour cette requête",
                    "best_match": best_candidate["title"],
                    "relevance": best_candidate["relevance"],
                    "query": search_query,
                }

            return {
                "success": True,
                "title": best_candidate["title"],
                "summary": best_candidate["summary"],
                "url": best_candidate["url"],
                "relevance": best_candidate["relevance"],
                "query": search_query,
            }

        except Exception as e:
            print(f"Erreur lors de la recherche Wikipedia: {str(e)}")
            return {
                "success": False,
                "error": f"Erreur lors de la recherche: {str(e)}",
                "query": search_query,
            }

    def get_wiki_score(self, title, summary, query, search_terms):
        score = 0.0  # up to 1
        title_lower = title.lower()
        query_lower = query.lower()
        term_in_title_count = sum(
            1 for term in search_terms if term.lower() in title_lower
        )
        title_term_score = term_in_title_count / max(1, len(search_terms))
        score += title_term_score * 0.3  # Le titre est très important
        best_sequence_match = 0

        for term in search_terms:
            sequence_similarity = SequenceMatcher(
                None, term.lower(), title_lower
            ).ratio()
            best_sequence_match = max(best_sequence_match, sequence_similarity)

        score += best_sequence_match * 0.4

        summary_lower = summary.lower()

        term_occurrences = sum(
            summary_lower.count(term.lower()) for term in search_terms
        )
        summary_term_score = min(1.0, term_occurrences / 5)
        score += summary_term_score * 0.2
        query_words = set(query_lower.split())
        common_words = sum(
            1 for word in query_words if word in summary_lower and len(word) > 3
        )
        context_score = min(1.0, common_words / max(5, len(query_words)))
        score += context_score * 0.1

        if len(summary) < 100:
            score -= 0.1

        return max(0.0, min(1.0, score))

    # LOCATION
    def get_location_name(self, user_input):
        doc = self.nlp(user_input)
        potential_locations = []
        best_location = None

        for ent in doc.ents:
            if ent.label_ == "LOC":
                potential_locations.append(ent.text)

        location_prepositions = [
            "à",
            "en",
            "au",
            "aux",
            "sur",
            "près de",
            "vers",
            "dans",
        ]
        for i, token in enumerate(doc):
            if token.text.lower() in location_prepositions and i < len(doc) - 1:
                span_start = i + 1
                span_end = span_start + 1

                while span_end < len(doc) and (
                    # only that is available in french with spacy
                    # much reduced from english version
                    doc[span_end].pos_ in ["PROPN", "NOUN", "ADJ"]
                    or doc[span_end].text
                    in ["de", "du", "des", "le", "la", "les", "l'"]
                ):
                    span_end += 1

                if span_end > span_start:
                    location_phrase = doc[span_start:span_end].text
                    if location_phrase and location_phrase not in potential_locations:
                        potential_locations.append(location_phrase)

        for location in potential_locations:
            coords = self.get_location_coords(location)

            if coords and "display_name" in coords:
                display_parts = coords["display_name"].split(", ")
                city_name = location

                if len(display_parts) > 1:
                    if len(display_parts[0]) < 3 and len(display_parts) > 1:
                        city_name = display_parts[1]
                    else:
                        city_name = display_parts[0]

                if len(display_parts) > 3 and any(
                    country_indicator in coords["display_name"].lower()
                    for country_indicator in [
                        "france",
                        "suisse",
                        "allemagne",
                        "italie",
                        "espagne",
                    ]
                ):
                    reverse_geo = self.reverse_geocode(coords["lat"], coords["lon"])
                    if reverse_geo and "address" in reverse_geo:
                        address = reverse_geo["address"]
                        city_name = address.get(
                            "city",
                            address.get("town", address.get("village", city_name)),
                        )

                best_location = {
                    "name": city_name,
                    "original": location,
                    "coords": coords,
                    "confidence": 1.0,
                }

                break

        if not best_location or not coords:
            return False

        return best_location["name"]

    def get_location(self):
        try:
            response = requests.get("https://ipapi.co/json/", timeout=5)
            if response.status_code == 200:
                data = response.json()
                return {
                    "city": data.get("city", "Inconnue"),
                    "region": data.get("region", "Inconnue"),
                    "country": data.get("country_name", "Inconnu"),
                    "latitude": data.get("latitude"),
                    "longitude": data.get("longitude"),
                }
            return {"city": "Inconnue", "region": "Inconnue", "country": "Inconnu"}
        except Exception as e:
            print(f"Erreur de localisation: {e}")
            return {"city": "Inconnue", "region": "Inconnue", "country": "Inconnu"}

    def get_location_coords(self, location_name):
        try:
            url = f"https://nominatim.openstreetmap.org/search?q={location_name}&format=json&limit=1"

            headers = {
                "User-Agent": "QwenAssistant/1.0",
                "Accept-Language": "fr-FR,fr;q=0.9",
            }

            response = requests.get(url, headers=headers, timeout=5)
            if response.status_code == 200:
                data = response.json()
                if data and len(data) > 0:
                    return {
                        "lat": float(data[0]["lat"]),
                        "lon": float(data[0]["lon"]),
                        "display_name": data[0]["display_name"],
                    }
                else:
                    print(f"Lieu non trouvé: {location_name}")
                    return None
            else:
                print(f"Erreur lors de la recherche du lieu: {response.status_code}")
                return None
        except Exception as e:
            print(f"Erreur de géocodage: {e}")

    # WEATHER
    def add_weather(self, user_input, extra_info, query_type):
        location_name = None
        weather_analysis = self.need4weather(user_input)

        if weather_analysis["location_entities"]:
            location_name = weather_analysis["location_entities"][0]

        if not location_name:
            loc = self.get_location()
            location_name = loc["city"] if loc["city"] != "Inconnue" else None

        forecast_days = query_type.get("forecast_days", 0)
        forecast_data = self.get_weather_forecast(location_name)

        if forecast_data["success"]:
            if "forecast" in forecast_data and isinstance(
                forecast_data["forecast"], list
            ):
                extra_info["weather_forecast"] = forecast_data
            else:
                transformed_forecast = {
                    "success": True,
                    "location": {
                        "name": location_name or "Inconnue",
                        "coordinates": forecast_data.get(
                            "coordinates", {"lat": 0, "lon": 0}
                        ),
                        "query": {
                            "city": location_name or "Inconnue",
                            "display_name": location_name or "Inconnue",
                            "source": "specified" if location_name else "default",
                        },
                    },
                    "forecast": forecast_data.get("forecast", []),
                    "timestamp": int(time.time()),
                    "source": "OpenWeatherMap",
                    "facts": forecast_data.get("facts", []),
                }
                extra_info["weather_forecast"] = transformed_forecast

            extra_info["forecast_days_requested"] = forecast_days

            if "weekend" in query_type:
                extra_info["forecast_days_requested_weekend"] = query_type.get(
                    "weekend", False
                )

        if forecast_days == 0:
            weather_data = self.return_weather(location_name=location_name)
            if weather_data["success"]:
                extra_info["weather"] = weather_data

    def has_weather(self, extra_info):
        """Vérifie si on dispose d'informations météo"""
        return (
            "weather" in extra_info
            or "weather_forecast" in extra_info
            or (
                "web_search" in extra_info
                and (
                    "weather" in extra_info["web_search"]
                    or "weather_forecast" in extra_info["web_search"]
                )
            )
        )

    def reverse_geocode(self, lat, lon):
        try:
            url = f"https://nominatim.openstreetmap.org/reverse?lat={lat}&lon={lon}&format=json"

            headers = {
                "User-Agent": "QwenAssistant/1.0",
                "Accept-Language": "fr-FR,fr;q=0.9",
            }

            response = requests.get(url, headers=headers, timeout=5)
            if response.status_code == 200:
                return response.json()
            else:
                return None
        except Exception as e:
            print(f"Erreur de géocodage inverse: {e}")
            return None

    def need4weather(self, user_input):
        doc = self.nlp(user_input)

        location_entities = []

        for ent in doc.ents:
            if ent.label_ in ["LOC"]:
                entity_info = {"text": ent.text, "label": ent.label_, "is_known": False}
                location_entities.append(entity_info)

        weather_indicators = {
            "direct_query": False,
            "temporal_context": False,
            "condition_query": False,
            "forecast_query": False,
        }

        weather_keywords = [
            "météo",
            "temps",
            "température",
            "climat",
            "pleut",
            "pluie",
            "neige",
            "ensoleillé",
            "soleil",
            "nuages",
            "nuageux",
            "orage",
            "chaud",
            "froid",
            "humidité",
            "vent",
            "degrés",
            "celsius",
        ]

        temporal_indicators = [
            "aujourd'hui",
            "maintenant",
            "en ce moment",
            "actuellement",
            "demain",
            "ce soir",
            "cette nuit",
            "ce matin",
            "cette après-midi",
            "cette semaine",
            "ce weekend",
            "prochains jours",
        ]

        if any(keyword in user_input.lower() for keyword in weather_keywords):
            weather_indicators["direct_query"] = True

        if any(indicator in user_input.lower() for indicator in temporal_indicators):
            weather_indicators["temporal_context"] = True

        condition_patterns = [
            "il pleut",
            "il va pleuvoir",
            "il neige",
            "il va neiger",
            "fait-il",
            "fera-t-il",
            "va-t-il faire",
            "est-ce qu'il fait",
            "est-ce qu'il va faire",
            "quelle température",
        ]
        if any(pattern in user_input.lower() for pattern in condition_patterns):
            weather_indicators["condition_query"] = True

        forecast_patterns = [
            "prévisions",
            "prévu",
            "annoncé",
            "demain",
            "prochain",
            "cette semaine",
            "ce weekend",
            "dans les jours à venir",
        ]
        if any(pattern in user_input.lower() for pattern in forecast_patterns):
            weather_indicators["forecast_query"] = True

        weather_necessity = 0.0

        if weather_indicators["direct_query"]:
            weather_necessity += 0.4
        if weather_indicators["temporal_context"]:
            weather_necessity += 0.2
        if weather_indicators["condition_query"]:
            weather_necessity += 0.3
        if weather_indicators["forecast_query"]:
            weather_necessity += 0.3

        weather_necessity += min(0.3, len(location_entities) * 0.2)

        location_terms = []

        if location_entities:
            for entity in location_entities:
                location_terms.append(entity["text"])
        else:
            for chunk in doc.noun_chunks:
                if len(chunk.text) > 3 and not any(
                    keyword in chunk.text.lower() for keyword in weather_keywords
                ):
                    location_terms.append(chunk.text)
                    if len(location_terms) >= 2:  # Limiter à 2 termes
                        break

        result = {
            "requires_weather": weather_necessity >= 0.3,
            "weather_necessity_score": weather_necessity,
            "weather_indicators": weather_indicators,
            "location_entities": [e["text"] for e in location_entities],
            "location_terms": location_terms[:2],
            "default_location": len(location_terms) == 0,
        }

        return result

    def return_weather(
        self, query=None, location_terms=None, lat=None, lon=None, location_name=None
    ):
        """
        gets current weather data from OpenWeatherMap API.
        """
        try:
            location = None
            coordinates = None

            if lat is not None and lon is not None:
                coordinates = {"lat": lat, "lon": lon}
                location = {"source": "coordinates", "lat": lat, "lon": lon}

                try:
                    reverse_geocode = self.reverse_geocode(lat, lon)
                    if reverse_geocode and "display_name" in reverse_geocode:
                        location["city"] = reverse_geocode.get(
                            "display_name", "Lieu inconnu"
                        )
                except Exception as e:
                    print(f"Échec de la géolocalisation inverse: {str(e)}")
                    location["city"] = CONFIG.location.default_location

            elif location_name:
                coords = self.get_location_coords(location_name)
                if coords:
                    coordinates = {"lat": coords["lat"], "lon": coords["lon"]}
                    location = {
                        "city": location_name,
                        "display_name": coords.get("display_name", location_name),
                        "source": "specified",
                    }

            elif location_terms and len(location_terms) > 0:
                for term in location_terms:
                    coords = self.get_location_coords(term)
                    if coords:
                        coordinates = {"lat": coords["lat"], "lon": coords["lon"]}
                        location = {
                            "city": term,
                            "display_name": coords.get("display_name", term),
                            "source": "query",
                        }
                        break

            if not coordinates:
                default_location = self.get_location()
                location = {
                    "city": default_location.get("city", "Inconnue"),
                    "region": default_location.get("region", ""),
                    "country": default_location.get("country", ""),
                    "source": "default",
                }
                coordinates = {
                    "lat": default_location.get(
                        "latitude", CONFIG.location.default_latitude
                    ),
                    "lon": default_location.get(
                        "longitude", CONFIG.location.default_longitude
                    ),
                }

            api_key = self.openWeatherKey()
            if not api_key:
                return {
                    "success": False,
                    "error": "No OpenWeatherMap API key configured",
                    "location": location,
                    "query": query,
                }

            url = f"https://api.openweathermap.org/data/2.5/weather?lat={coordinates['lat']}&lon={coordinates['lon']}&appid={api_key}&units=metric&lang=fr"
            response = requests.get(
                url,
                timeout=CONFIG.weather.api_timeout
                if hasattr(CONFIG.weather, "api_timeout")
                else 5,
            )

            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"Error from weather API (code {response.status_code})",
                    "location": location,
                    "query": query,
                }

            data = response.json()

            weather_data = {
                "success": True,
                "temperature": data["main"]["temp"],
                "feels_like": data["main"]["feels_like"],
                "min_temp": data["main"]["temp_min"],
                "max_temp": data["main"]["temp_max"],
                "pressure": data["main"]["pressure"],
                "humidity": data["main"]["humidity"],
                "description": data["weather"][0]["description"],
                "icon": data["weather"][0]["icon"],
                "main": data["weather"][0]["main"],
                "wind_speed": data.get("wind", {}).get("speed", 0),
                "wind_direction": data.get("wind", {}).get("deg", 0),
                "clouds": data.get("clouds", {}).get("all", 0),
                "visibility": data.get("visibility", 0),
                "location": {
                    "name": data.get("name", location.get("city", "Inconnue")),
                    "country": data.get("sys", {}).get("country", ""),
                    "sunrise": data.get("sys", {}).get("sunrise", 0),
                    "sunset": data.get("sys", {}).get("sunset", 0),
                    "timezone": data.get("timezone", 0),
                },
                "query_location": location,
                "coordinates": coordinates,
                "timestamp": int(time.time()),
            }

            if query:
                weather_data["query"] = query
                relevance_score = self.get_weather_score(
                    weather_data, query, location_terms
                )
                weather_data["relevance"] = relevance_score

            return weather_data

        except Exception as e:
            print(f"Error getting weather data : {e}")
            return {
                "success": False,
                "error": f"Error: {str(e)}",
                "location": location
                if location
                else {"city": "Unknown", "source": "error"},
                "query": query,
            }

    def get_weather_score(self, weather_data, query, location_terms=None):
        score = 0.6  # High basis

        location_match_score = 0.0

        if weather_data["query_location"]["source"] == "query":
            location_match_score = 0.3
        else:
            location_match_score = 0.1

        score += location_match_score

        current_time = int(time.time())
        data_age = current_time - weather_data["timestamp"]

        if data_age < 1800:
            score += 0.1

        query_lower = query.lower()

        weather_main = weather_data["main"].lower()
        weather_desc = weather_data["description"].lower()

        condition_matches = {
            "pluie": ["rain", "pluie", "pluvieux"],
            "neige": ["neige", "neigeux"],
            "nuage": ["nuage", "nuageux"],
            "soleil": ["soleil", "ensoleillé"],
            "orage": ["orage", "orageux"],
            "brouillard": ["brouillard", "brume"],
        }

        for condition_term, condition_values in condition_matches.items():
            if condition_term in query_lower:
                if any(
                    val in weather_main or val in weather_desc
                    for val in condition_values
                ):
                    score += 0.2
                    break

        temp_patterns = {
            "chaud": lambda t: t > 25,
            "chaleur": lambda t: t > 25,
            "froid": lambda t: t < 10,
            "frais": lambda t: t < 15,
            "gel": lambda t: t <= 0,
            "gelée": lambda t: t <= 0,
            "canicule": lambda t: t > 30,
        }

        current_temp = weather_data["temperature"]

        for temp_term, condition in temp_patterns.items():
            if temp_term in query_lower and condition(current_temp):
                score += 0.2
                break

        return min(1.0, score)

    def openWeatherKey(self):
        try:
            api_key = os.environ.get("OPENWEATHERMAP_API_KEY")
            return api_key
        except Exception:
            logger.info(
                "Please get an OpenWeatherMap API key if you want to access weather data and\nexport in your envirronement variables"
            )
            return None

    def get_weather_forecast(
        self, location_name=None, days=5
    ):  # max forecast 5 days with openweather
        try:
            coordinates = None
            location = None

            if location_name:
                coords = self.get_location_coords(location_name)
                if coords:
                    coordinates = {"lat": coords["lat"], "lon": coords["lon"]}
                    location = {
                        "city": location_name,
                        "display_name": coords.get("display_name", location_name),
                        "source": "specified",
                    }

            if not coordinates:
                default_location = self.get_location()
                location = {
                    "city": default_location.get("city", "Inconnue"),
                    "region": default_location.get("region", ""),
                    "country": default_location.get("country", ""),
                    "source": "default",
                }
                coordinates = {
                    "lat": default_location.get("latitude", 48.8566),
                    "lon": default_location.get("longitude", 2.3522),
                }

            api_key = self.openWeatherKey()
            url = f"https://api.openweathermap.org/data/2.5/forecast?lat={coordinates['lat']}&lon={coordinates['lon']}&appid={api_key}&units=metric&lang=fr"

            response = requests.get(url, timeout=5)

            if response.status_code != 200:
                return {
                    "success": False,
                    "error": f"Erreur API prévisions (code {response.status_code})",
                    "location": location,
                }

            data = response.json()
            forecast_by_day = {}
            city_name = data["city"]["name"]

            for item in data["list"]:
                dt = datetime.fromtimestamp(item["dt"])

                date_str = dt.strftime("%Y-%m-%d")
                if date_str not in forecast_by_day:
                    forecast_by_day[date_str] = {
                        "date": date_str,
                        "day_name": dt.strftime("%A"),
                        "min_temp": float("inf"),
                        "max_temp": float("-inf"),
                        "humidity_avg": 0,
                        "pressure_avg": 0,
                        "wind_speed_avg": 0,
                        "descriptions": [],
                        "icons": [],
                        "timestamps": [],
                        "forecast_points": 0,
                    }

                day_data = forecast_by_day[date_str]
                day_data["min_temp"] = min(
                    day_data["min_temp"], item["main"]["temp_min"]
                )
                day_data["max_temp"] = max(
                    day_data["max_temp"], item["main"]["temp_max"]
                )
                day_data["humidity_avg"] += item["main"]["humidity"]
                day_data["pressure_avg"] += item["main"]["pressure"]
                day_data["wind_speed_avg"] += item["wind"]["speed"]
                day_data["descriptions"].append(item["weather"][0]["description"])
                day_data["icons"].append(item["weather"][0]["icon"])
                day_data["timestamps"].append(item["dt"])
                day_data["forecast_points"] += 1

            daily_forecasts = []

            for date_str, day_data in sorted(forecast_by_day.items()):
                if day_data["forecast_points"] > 0:
                    day_data["humidity_avg"] /= day_data["forecast_points"]
                    day_data["pressure_avg"] /= day_data["forecast_points"]
                    day_data["wind_speed_avg"] /= day_data["forecast_points"]

                desc_counter = Counter(day_data["descriptions"])
                day_data["main_description"] = desc_counter.most_common(1)[0][0]
                icon_counter = Counter(day_data["icons"])
                day_data["main_icon"] = icon_counter.most_common(1)[0][0]
                del day_data["descriptions"]
                del day_data["icons"]

                daily_forecasts.append(day_data)

            result = {
                "success": True,
                "location": {
                    "name": city_name,
                    "coordinates": coordinates,
                    "query": location,
                },
                "forecast": daily_forecasts[:days],
                "timestamp": int(time.time()),
                "source": "OpenWeatherMap",
            }
            return result

        except Exception as e:
            print(f"Error in weather forecast: {e}")
            return {
                "success": False,
                "error": f"Erreur: {str(e)}",
                "location": location
                if location
                else {"city": "Unknown", "source": "error"},
            }

    # GENERAL
    def classify_query(self, user_input):
        """Détecte le type de requête"""
        user_input_lower = user_input.lower()
        query_type = {
            "weather": False,
            "time": False,
            "date": False,
            "location": False,
            "pokemon": self.pokemon_query,
            "forecast_days": 0,
        }

        weather_keywords = [
            "météo",
            "temps qu'il fait",
            "température",
            "climat",
            "pleut",
            "froid",
            "neige",
            "pluie",
            "ensoleillé",
            "soleil",
            "nuages",
            "demain",
            "prévisions",
            "prévision",
            "fera-t-il",
            "fera t-il",
            "temps fera",
            "va-t-il faire",
            "quel temps",
            "temps sera",
            "sera-t-il",
            "sera t-il",
        ]
        time_keywords = ["heure", "quelle heure"]
        date_keywords = [
            "date",
            "jour",
            "quel jour",
            "on est quel jour",
            "aujourd'hui",
            "quelle date",
            "calendrier",
        ]
        location_keywords = ["où suis-je", "ma position", "ma localisation", "ville"]

        jours_semaine = {
            "lundi": 0,
            "mardi": 1,
            "mercredi": 2,
            "jeudi": 3,
            "vendredi": 4,
            "samedi": 5,
            "dimanche": 6,
        }

        try:
            query_type["weather"] = any(
                keyword in user_input_lower for keyword in weather_keywords
            )
        except KeyError:
            pass
        try:
            query_type["time"] = any(
                keyword in user_input_lower for keyword in time_keywords
            )
        except KeyError:
            pass
        try:
            query_type["date"] = any(
                keyword in user_input_lower for keyword in date_keywords
            )
        except KeyError:
            pass
        try:
            query_type["location"] = any(
                keyword in user_input_lower for keyword in location_keywords
            ) or self.get_location_name(user_input)
        except IndexError:
            pass

        self.weather_query = query_type["weather"]
        self.date_query = query_type["date"]
        self.location_query = query_type["location"]
        self.time_query = query_type["time"]

        if query_type["weather"]:
            if "aujourd'hui" in user_input_lower:
                query_type["forecast_days"] = 0
            elif "demain" in user_input_lower:
                query_type["forecast_days"] = 1
            elif (
                "après-demain" in user_input_lower or "après demain" in user_input_lower
            ):
                query_type["forecast_days"] = 2

            for i in range(2, 5):
                if f"dans {i} jour" in user_input_lower:
                    query_type["forecast_days"] = i
                    break

            today = datetime.now().weekday()  # 0=monday, 6=sunday
            if "week-end" in user_input_lower or "weekend" in user_input_lower:
                if "ce" in user_input_lower:
                    days_to_saturday = (5 - today) % 7
                    if days_to_saturday == 0 and datetime.now().hour >= 18:
                        query_type["forecast_days"] = 1
                    else:
                        query_type["forecast_days"] = days_to_saturday
                    query_type["weekend"] = True

            for index in jours_semaine.keys():
                if index in user_input_lower:
                    # print(f"index : {index}")
                    index_num = jours_semaine[index]
                    # print(f"index_num : {index_num}")
                    if index_num - today > 0:
                        days_diff = index_num - today
                    elif today - index_num > 0:
                        days_diff = 7 - (today - index_num)
                    elif today - index_num == 0:
                        days_diff = 7

                    # print(f"différence en nombre de jours : {days_diff}")
                    query_type["forecast_days"] = days_diff
                    break

            if "semaine" in user_input_lower or "prochains jours" in user_input_lower:
                query_type["forecast_days"] = -1

        return query_type

    def get_info(self, query_type, user_input):
        extra_info = {}

        if query_type["location"]:
            extra_info["location"] = self.get_location_name(user_input)

        now = datetime.now()
        extra_info["time"] = (
            f"{now.hour} heure{'s' if now.hour > 1 else ''} {now.minute:02d}"
        )

        month_names = [
            "janvier",
            "février",
            "mars",
            "avril",
            "mai",
            "juin",
            "juillet",
            "août",
            "septembre",
            "octobre",
            "novembre",
            "décembre",
        ]
        day_names = [
            "lundi",
            "mardi",
            "mercredi",
            "jeudi",
            "vendredi",
            "samedi",
            "dimanche",
        ]
        day_of_week = day_names[now.weekday()]
        month_name = month_names[now.month - 1]
        extra_info["date"] = f"{day_of_week} {now.day} {month_name} {now.year}"

        return extra_info

    def update_info(self, user_input, extra_info, web_search_results, query_type):
        if web_search_results:
            extra_info["web_search"] = web_search_results

            if "weather_forecast" in web_search_results:
                extra_info["weather_forecast"] = web_search_results["weather_forecast"]
                extra_info["forecast_days_requested"] = query_type.get(
                    "forecast_days", 0
                )
                print(
                    f"forecast days requested variable : {extra_info['forecast_days_requested']}"
                )
                if "weekend" in query_type:
                    extra_info["forecast_days_requested_weekend"] = query_type.get(
                        "weekend", False
                    )
            if "weather" in web_search_results:
                extra_info["weather"] = web_search_results["weather"]
            if "pokepedia" in web_search_results:
                extra_info["pokemon"] = web_search_results["pokepedia"]

        if query_type["weather"] and not (
            extra_info.get("weather") or extra_info.get("weather_forecast")
        ):
            self.add_weather(user_input, extra_info, query_type)
